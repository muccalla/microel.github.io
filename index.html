<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ”¹ NFC Mifare Editor ðŸ”¹</title>
    <style>
        /* Existing styles remain unchanged */
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ”¹ NFC Mifare Editor ðŸ”¹</h1>
        <div class="top-buttons">
            <button class="lang-toggle" id="langToggle">ðŸ‡¬ðŸ‡§ EN</button>
            <div class="switch">
                <input type="checkbox" class="switch__input" id="Switch">
                <label class="switch__label" for="Switch">
                    <span class="switch__indicator"></span>
                    <span class="switch__decoration"></span>
                </label>
            </div>
        </div>

        <div class="section">
            <div class="file-input">
                <label for="fileInput">ðŸ“‚ Carica File NFC</label>
                <input type="file" id="fileInput" accept=".nfc,.txt,.mct">
            </div>
        </div>

        <!-- Rest of the HTML remains unchanged -->
    </div>

    <script>
        let fileContent = null;
        let block0 = Array(16).fill(0), keys = Array(16).fill(0), lastOpCredit = Array(16).fill(0), lastOpDate = Array(16).fill(0);
        let block0Hex = Array(16).fill("00"), keysHex = Array(16).fill("00"), lastOpCreditHex = Array(16).fill("00"), lastOpDateHex = Array(16).fill("00");
        let sectorKeys = {};
        let language = "it";

        const texts = {
            it: {
                // Existing translations unchanged
            },
            en: {
                // Existing translations unchanged
            }
        };

        // Populate dropdowns (unchanged)
        for (let i = 0; i < 256; i++) {
            const opt = document.createElement("option");
            opt.value = i; opt.text = i.toString(16).padStart(2, "0").toUpperCase();
            ["uid0", "uid1", "uid2", "uid3"].forEach(id => document.getElementById(id).appendChild(opt.cloneNode(true)));
        }
        for (let i = 1; i <= 31; i++) {
            const opt = document.createElement("option");
            opt.value = i; opt.text = i;
            ["day", "lastOpDay"].forEach(id => document.getElementById(id).appendChild(opt.cloneNode(true)));
        }
        texts.it.months.forEach((m, i) => {
            const opt = document.createElement("option");
            opt.value = i + 1; opt.text = m;
            ["month", "lastOpMonth"].forEach(id => document.getElementById(id).appendChild(opt.cloneNode(true)));
        });
        for (let i = 2010; i <= 2040; i++) {
            const opt = document.createElement("option");
            opt.value = i; opt.text = i;
            ["year", "lastOpYear"].forEach(id => document.getElementById(id).appendChild(opt.cloneNode(true)));
        }
        for (let i = 0; i < 24; i++) {
            const opt = document.createElement("option");
            opt.value = i; opt.text = i.toString().padStart(2, "0");
            ["hours", "lastOpHours"].forEach(id => document.getElementById(id).appendChild(opt.cloneNode(true)));
        }
        for (let i = 0; i < 60; i++) {
            const opt = document.createElement("option");
            opt.value = i; opt.text = i.toString().padStart(2, "0");
            ["minutes", "lastOpMinutes"].forEach(id => document.getElementById(id).appendChild(opt.cloneNode(true)));
        }

        // Toggle fields (unchanged)
        ["keepUid", "keepCredit", "keepDate", "keepLastOpCredit", "keepLastOpDate"].forEach(id => {
            document.getElementById(id).addEventListener("change", e => {
                const prefix = id.replace("keep", "").toLowerCase();
                const inputs = prefix === "uid" ? ["uid0", "uid1", "uid2", "uid3"] :
                              prefix === "credit" ? ["newCredit"] :
                              prefix === "date" ? ["day", "month", "year", "hours", "minutes"] :
                              prefix === "lastopcredit" ? ["newLastOpCredit"] :
                              ["lastOpDay", "lastOpMonth", "lastOpYear", "lastOpHours", "lastOpMinutes"];
                inputs.forEach(inputId => document.getElementById(inputId).disabled = e.target.checked);
            });
        });

        // Language toggle (unchanged)
        document.getElementById("langToggle").addEventListener("click", () => {
            language = language === "it" ? "en" : "it";
            document.getElementById("langToggle").textContent = language === "it" ? "ðŸ‡¬ðŸ‡§ EN" : "ðŸ‡®ðŸ‡¹ IT";
            document.querySelector(".file-input label").textContent = texts[language].loadFile;
            document.querySelectorAll(".section h3")[0].textContent = "ðŸ“‹ " + (language === "it" ? "Dati Estratti" : "Extracted Data");
            document.querySelectorAll(".section h3")[1].textContent = "âœï¸ " + (language === "it" ? "Modifica Dati" : "Edit Data");
            ["uid", "credit", "date", "encoding", "lastOpCredit", "lastOpDate"].forEach(field => {
                document.querySelector(`#${field}`).previousElementSibling.textContent = texts[language][field] + ":";
            });
            ["keepUid", "newUid", "keepCredit", "newCredit", "keepDate", "newDate", "keepLastOpCredit", "newLastOpCredit", "keepLastOpDate", "newLastOpDate"].forEach(field => {
                const elem = document.querySelector(`#${field.replace(/([A-Z])/g, '-$1').toLowerCase()}`).parentElement.querySelector("label");
                elem.textContent = texts[language][field] + (field.startsWith("keep") ? "" : ":");
            });
            document.querySelectorAll(".section button")[0].textContent = texts[language].updateSame;
            document.querySelectorAll(".section button")[1].textContent = texts[language].updateNew;
            ["month", "lastOpMonth"].forEach(id => {
                const select = document.getElementById(id);
                select.innerHTML = "";
                texts[language].months.forEach((m, i) => {
                    const opt = document.createElement("option");
                    opt.value = i + 1; opt.text = m;
                    select.appendChild(opt);
                });
            });
            updateUI();
        });

        // Theme toggle (unchanged)
        document.getElementById("Switch").addEventListener("change", (e) => {
            document.body.classList.toggle("dark", e.target.checked);
            document.querySelector(".container").classList.toggle("dark", e.target.checked);
        });

        document.getElementById("fileInput").addEventListener("change", () => {
            const file = document.getElementById("fileInput").files[0];
            if (file) loadFile(file);
        });

        function loadFile(file) {
            const reader = new FileReader();
            reader.onload = () => {
                fileContent = reader.result;
                document.getElementById("fileContent").value = fileContent;
                parseFile(file.name);
            };
            reader.readAsText(file);
        }

        function parseFile(filename) {
            const lines = fileContent.split("\n").map(line => line.trim());
            let block0Found = false, block4Found = false, block5Found = false, block6Found = false;
            sectorKeys = {};
            block0 = Array(16).fill(0); keys = Array(16).fill(0); lastOpCredit = Array(16).fill(0); lastOpDate = Array(16).fill(0);
            block0Hex = Array(16).fill("00"); keysHex = Array(16).fill("00"); lastOpCreditHex = Array(16).fill("00"); lastOpDateHex = Array(16).fill("00");

            if (filename.endsWith(".mct")) {
                let currentSector = -1;
                let blockCounter = 0;

                lines.forEach(line => {
                    if (line.startsWith("+Sector:")) {
                        currentSector = parseInt(line.split(":")[1].trim());
                        blockCounter = 0;
                    } else if (currentSector >= 0 && line && !line.startsWith("-") && !line.startsWith("#")) {
                        const data = line.split(/\s+/).filter(x => x).map(x => x.replace(/[^0-9A-Fa-f]/g, ""));
                        if (data.length >= 16) {
                            const blockNum = currentSector * 4 + blockCounter;
                            if (blockNum === 0) {
                                block0Hex = data.slice(0, 16);
                                block0 = block0Hex.map(x => parseInt(x, 16));
                                block0Found = true;
                            } else if (blockNum === 4) {
                                keysHex = data.slice(0, 16);
                                keys = keysHex.map(x => parseInt(x, 16));
                                block4Found = true;
                            } else if (blockNum === 5) {
                                lastOpCreditHex = data.slice(0, 16);
                                lastOpCredit = lastOpCreditHex.map(x => parseInt(x, 16));
                                block5Found = true;
                            } else if (blockNum === 6) {
                                lastOpDateHex = data.slice(0, 16);
                                lastOpDate = lastOpDateHex.map(x => parseInt(x, 16));
                                block6Found = true;
                            } else if (blockCounter === 3) { // Sector trailer (keys A and B)
                                sectorKeys[currentSector] = [
                                    data.slice(0, 6).join("").toUpperCase(), // Key A
                                    data.slice(10, 16).join("").toUpperCase() // Key B
                                ];
                            }
                            blockCounter++;
                        }
                    }
                });
            } else { // Existing .nfc/.txt parsing
                lines.forEach(line => {
                    if (line.startsWith("Block ")) {
                        const parts = line.split(/\s+/);
                        const blockNum = parseInt(parts[1].replace(":", ""));
                        const data = parts.slice(2);
                        if (data.length >= 16) {
                            if (blockNum === 0) {
                                block0Hex = data.slice(0, 16);
                                block0 = block0Hex.map(x => parseInt(x, 16));
                                block0Found = true;
                            } else if (blockNum === 4) {
                                keysHex = data.slice(0, 16);
                                keys = keysHex.map(x => parseInt(x, 16));
                                block4Found = true;
                            } else if (blockNum === 5) {
                                lastOpCreditHex = data.slice(0, 16);
                                lastOpCredit = lastOpCreditHex.map(x => parseInt(x, 16));
                                block5Found = true;
                            } else if (blockNum === 6) {
                                lastOpDateHex = data.slice(0, 16);
                                lastOpDate = lastOpDateHex.map(x => parseInt(x, 16));
                                block6Found = true;
                            }
                        }
                        if (blockNum % 4 === 3 && parts.length >= 18) {
                            sectorKeys[Math.floor(blockNum / 4)] = [
                                parts.slice(2, 8).join("").toUpperCase(),
                                parts.slice(12, 18).join("").toUpperCase()
                            ];
                        }
                    }
                });
            }

            if (!(block0Found && block4Found && block5Found && block6Found)) {
                alert(texts[language].errorBlock);
                return;
            }

            updateUI();
        }

        // Rest of the functions (updateUI, calculateCredit, etc.) remain unchanged
        function updateUI() {
            document.getElementById("uid").textContent = block0Hex.slice(0, 4).join(" ") || "00 00 00 00";
            document.getElementById("credit").textContent = calculateCredit().toFixed(2) + " â‚¬";
            document.getElementById("date").textContent = calculateDate();
            document.getElementById("encoding").textContent = detectEncodingType();
            document.getElementById("lastOpCredit").textContent = calculateLastOpCredit().toFixed(2) + " â‚¬";
            document.getElementById("lastOpDate").textContent = calculateLastOpDate();
        }

        function calculateCredit() {
            return ((keys[6] << 8) | keys[5]) / 100;
        }

        function calculateDate() {
            const b = (keys[10] << 24) | (keys[9] << 16) | (keys[8] << 8) | keys[7];
            if (b === 0) return "N/A";
            const minutes = (b >> 21) & 0x3F;
            const hours = (b >> 16) & 0x1F;
            const year = 2010 + ((b >> 9) & 0x1F);
            const month = (b >> 5) & 0x0F;
            const day = b & 0x1F;
            return `${day} ${texts[language].months[month - 1] || "invalid"} ${year} ${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
        }

        function calculateLastOpCredit() {
            return ((lastOpCredit[6] << 8) | lastOpCredit[5]) / 100;
        }

        function calculateLastOpDate() {
            const b = (lastOpDate[10] << 24) | (lastOpDate[9] << 16) | (lastOpDate[8] << 8) | lastOpDate[7];
            if (b === 0) return "N/A";
            const minutes = (b >> 21) & 0x3F;
            const hours = (b >> 16) & 0x1F;
            const year = 2010 + ((b >> 9) & 0x1F);
            const month = (b >> 5) & 0x0F;
            const day = b & 0x1F;
            return `${day} ${texts[language].months[month - 1] || "invalid"} ${year} ${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
        }

        function detectEncodingType() {
            if (!Object.keys(sectorKeys).length) return language === "it" ? "sconosciuta" : "unknown";
            let isMicroel = true;
            for (let s of [0, 1]) {
                if (!sectorKeys[s] || sectorKeys[s][0] === "FFFFFFFFFFFF" || sectorKeys[s][1] === "FFFFFFFFFFFF") isMicroel = false;
            }
            for (let s = 2; s < 16; s++) {
                if (!sectorKeys[s] || sectorKeys[s][0] !== "FFFFFFFFFFFF" || sectorKeys[s][1] !== "FFFFFFFFFFFF") isMicroel = false;
            }
            return isMicroel ? "microel" : (language === "it" ? "sconosciuta" : "unknown");
        }

        function calculateChecksum() {
            return (keys.slice(0, -1).reduce((a, b) => a + b, 0) + 0x21) % 256;
        }

        function updateFile(isNew) {
            if (!fileContent) {
                alert(texts[language].errorLoad);
                return;
            }
            try {
                if (!document.getElementById("keepCredit").checked) {
                    const newCredit = parseFloat(document.getElementById("newCredit").value);
                    if (isNaN(newCredit) || newCredit < 0) throw new Error();
                    const creditInt = Math.round(newCredit * 100);
                    keys[5] = creditInt & 0xFF;
                    keys[6] = (creditInt >> 8) & 0xFF;
                }
                if (!document.getElementById("keepDate").checked) {
                    const day = parseInt(document.getElementById("day").value);
                    const month = parseInt(document.getElementById("month").value);
                    const year = parseInt(document.getElementById("year").value) - 2010;
                    const hours = parseInt(document.getElementById("hours").value);
                    const minutes = parseInt(document.getElementById("minutes").value);
                    const timestamp = (day & 0x1F) | (month << 5) | (year << 9) | (1 << 14) | (hours << 16) | (minutes << 21);
                    keys[7] = timestamp & 0xFF;
                    keys[8] = (timestamp >> 8) & 0xFF;
                    keys[9] = (timestamp >> 16) & 0xFF;
                    keys[10] = (timestamp >> 24) & 0xFF;
                }
                keys[15] = calculateChecksum();
                keysHex = keys.map(x => x.toString(16).padStart(2, "0").toUpperCase());

                if (!document.getElementById("keepLastOpCredit").checked) {
                    const newLastOpCredit = parseFloat(document.getElementById("newLastOpCredit").value);
                    if (isNaN(newLastOpCredit) || newLastOpCredit < 0) throw new Error();
                    const creditInt = Math.round(newLastOpCredit * 100);
                    lastOpCredit[5] = creditInt & 0xFF;
                    lastOpCredit[6] = (creditInt >> 8) & 0xFF;
                    lastOpCreditHex = lastOpCredit.map(x => x.toString(16).padStart(2, "0").toUpperCase());
                }
                if (!document.getElementById("keepLastOpDate").checked) {
                    const day = parseInt(document.getElementById("lastOpDay").value);
                    const month = parseInt(document.getElementById("lastOpMonth").value);
                    const year = parseInt(document.getElementById("lastOpYear").value) - 2010;
                    const hours = parseInt(document.getElementById("lastOpHours").value);
                    const minutes = parseInt(document.getElementById("lastOpMinutes").value);
                    const timestamp = (day & 0x1F) | (month << 5) | (year << 9) | (1 << 14) | (hours << 16) | (minutes << 21);
                    lastOpDate[7] = timestamp & 0xFF;
                    lastOpDate[8] = (timestamp >> 8) & 0xFF;
                    lastOpDate[9] = (timestamp >> 16) & 0xFF;
                    lastOpDate[10] = (timestamp >> 24) & 0xFF;
                    lastOpDateHex = lastOpDate.map(x => x.toString(16).padStart(2, "0").toUpperCase());
                }
                if (!document.getElementById("keepUid").checked) {
                    const newUid = [parseInt(document.getElementById("uid0").value), parseInt(document.getElementById("uid1").value),
                                    parseInt(document.getElementById("uid2").value), parseInt(document.getElementById("uid3").value)];
                    const uidXor = newUid[0] ^ newUid[1] ^ newUid[2] ^ newUid[3];
                    block0[0] = newUid[0]; block0[1] = newUid[1]; block0[2] = newUid[2]; block0[3] = newUid[3]; block0[4] = uidXor;
                    block0Hex = block0.map(x => x.toString(16).padStart(2, "0").toUpperCase());
                }

                const updatedContent = fileContent.split("\n").map(line => {
                    if (line.startsWith("Block 0:")) return `Block 0: ${block0Hex.join(" ")}`;
                    if (line.startsWith("Block 4:")) return `Block 4: ${keysHex.join(" ")}`;
                    if (line.startsWith("Block 5:")) return `Block 5: ${lastOpCreditHex.join(" ")}`;
                    if (line.startsWith("Block 6:")) return `Block 6: ${lastOpDateHex.join(" ")}`;
                    return line;
                }).join("\n");

                document.getElementById("fileContent").value = updatedContent;
                updateUI();

                const blob = new Blob([updatedContent], { type: "text/plain" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = isNew ? "new_nfc_file.nfc" : "updated_nfc_file.nfc";
                a.click();
                URL.revokeObjectURL(url);
            } catch (e) {
                alert(texts[language].errorValue);
            }
        }
    </script>
</body>
</html>
